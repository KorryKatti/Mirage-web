<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>MIRAGE // The Record Crate</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="css/messages.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@4.3.0/marked.min.js"></script>
</head>

<body>

    <aside class="sidebar">
        <div class="sidebar-header">
            <h2>RECORD_CRATE_ALPHA</h2>
            <button id="new-msg-btn" onclick="openNewMsg()"
                style="background:none; border:none; color:var(--record-yellow); cursor:pointer; font-size:1.5rem;">üìÅ</button>
        </div>
        <div id="convo-list" class="convo-list">
            <!-- Senders will be listed here as record spines -->
            <div style="padding: 20px; text-align: center; opacity: 0.5;">BROWSING_COLLECTION...</div>
        </div>
    </aside>

    <main class="chat-area">
        <header class="chat-header" id="chat-header" style="display: none;">
            <div class="active-user-name" id="active-user-name">SELECT_SIDE_A</div>
            <div class="header-nav">
                <a href="room.html">[ TO_THE_COURT ]</a>
                <a href="fyp.html">[ VIEW_COLLECTION ]</a>
            </div>
        </header>

        <div id="messages-container" class="messages-container">
            <div class="no-chat-selected">
                <h3 id="empty-state-text">START_THE_TURNTABLE</h3>
                <div style="font-size: 3rem; margin-top: 20px;">üíø</div>
            </div>
        </div>

        <div class="input-area" id="input-area" style="display: none;">
            <div class="control-panel">
                <div class="knob"></div>
                <input type="text" id="msg-input" placeholder="Inscribe liner notes..." autocomplete="off">
                <button id="send-btn">RELEASE_TRACK</button>
            </div>
        </div>
    </main>

    <script>
        let server_url = 'http://127.0.0.1:5000';
        const token = localStorage.getItem('token');
        const currentUser = localStorage.getItem('user');

        let allMessages = [];
        let conversations = {};
        let activeSender = null;

        if (!token || !currentUser) {
            window.location.href = 'index.html';
        }

        async function loadSettings() {
            try {
                const res = await fetch('settings.json');
                const settings = await res.json();
                if (settings.server_url) server_url = settings.server_url;
            } catch (e) { }
        }

        async function fetchInbox() {
            try {
                const res = await fetch(`${server_url}/api/inbox`, {
                    headers: { 'Authorization': token }
                });
                const data = await res.json();
                return data.messages || [];
            } catch (err) {
                console.error(err);
                return [];
            }
        }

        function groupMessages(messages) {
            const groups = {};
            messages.forEach(msg => {
                // Determine the other person in the conversation
                const partner = msg.sender === currentUser ? msg.recipient : msg.sender;

                if (!groups[partner]) {
                    groups[partner] = {
                        partner: partner,
                        avatar: 'default.png', // Default, will update if we find their message
                        messages: [],
                        lastMessage: msg
                    };
                }

                // If the message is FROM the partner, use their avatar for the conversation
                if (msg.sender === partner && msg.avatar_url) {
                    groups[partner].avatar = msg.avatar_url;
                }

                groups[partner].messages.push(msg);

                // Keep track of the truly last message for sorting
                if (new Date(msg.created_at) > new Date(groups[partner].lastMessage.created_at)) {
                    groups[partner].lastMessage = msg;
                }
            });
            return groups;
        }

        function renderConvoList() {
            const list = document.getElementById('convo-list');
            list.innerHTML = '';

            const sortedPartners = Object.values(conversations).sort((a, b) =>
                new Date(b.lastMessage.created_at) - new Date(a.lastMessage.created_at)
            );

            if (sortedPartners.length === 0) {
                list.innerHTML = '<div style="padding:20px; text-align:center; opacity:0.5; color:var(--cardboard);">CRATE_EMPTY</div>';
                return;
            }

            sortedPartners.forEach(convo => {
                const item = document.createElement('div');
                item.className = `convo-item ${activeSender === convo.partner ? 'active' : ''}`;
                item.onclick = () => selectConvo(convo.partner);

                item.innerHTML = `
          <img src="${convo.avatar}" class="avatar" alt="">
          <div class="convo-info">
            <span class="convo-name">${convo.partner}</span>
          </div>
          <div class="record-label-tag">LP</div>
        `;
                list.appendChild(item);
            });
        }

        function selectConvo(sender) {
            activeSender = sender;
            renderConvoList();

            document.getElementById('chat-header').style.display = 'flex';
            document.getElementById('input-area').style.display = 'flex';
            document.getElementById('active-user-name').textContent = `PLAYING: ${sender.toUpperCase()}`;

            renderMessages();
        }

        function renderMessages() {
            const container = document.getElementById('messages-container');
            container.innerHTML = '';

            const messages = conversations[activeSender].messages.slice().sort((a, b) =>
                new Date(a.created_at) - new Date(b.created_at)
            );

            messages.forEach(msg => {
                const div = document.createElement('div');
                const isSent = msg.sender === currentUser;
                div.className = isSent ? 'message sent' : 'message received';

                const timestamp = new Date(msg.created_at).toLocaleTimeString();
                const pfp = msg.avatar_url || 'https://i.pinimg.com/736x/b9/e8/db/b9e8db33168a26c9ca697a05ddc80937.jpg';

                div.innerHTML = `
          <div class="pfp-container">
            <img src="${pfp}" alt="artwork">
          </div>
          <div class="message-body">
            <div class="message-content">${marked.parse(msg.message)}</div>
            <div class="message-meta">TRACK_ID: ${timestamp} / ${isSent ? 'LOCAL_REC' : 'TRANS_IN'}</div>
          </div>
          <button class="delete-btn" onclick="deleteMessage(${msg.id}, event)">√ó</button>
        `;
                container.appendChild(div);
            });

            container.scrollTop = container.scrollHeight;
        }

        async function sendMessage() {
            const input = document.getElementById('msg-input');
            const text = input.value.trim();
            if (!text || !activeSender) return;

            const btn = document.getElementById('send-btn');
            btn.disabled = true;
            btn.textContent = '...';

            try {
                const res = await fetch(`${server_url}/api/send_inbox_message`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': token
                    },
                    body: JSON.stringify({
                        recipient: activeSender,
                        message: text
                    })
                });

                const data = await res.json();
                if (data.message) {
                    input.value = '';
                    // Re-fetch to get the official unified history
                    init();
                } else {
                    alert('Mastering Error: Needle scratch');
                }
            } catch (err) {
                alert('Signal Interruption: Store closed');
            } finally {
                btn.disabled = false;
                btn.textContent = 'RELEASE_TRACK';
            }
        }

        async function deleteMessage(id, event) {
            event.stopPropagation();
            if (!confirm('Shred this vinyl?')) return;

            try {
                await fetch(`${server_url}/api/delete_inbox_message`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': token
                    },
                    body: JSON.stringify({ message_id: id })
                });
                init(); // Refresh all
            } catch (e) { }
        }

        function openNewMsg() {
            const recipient = prompt("Enter Artist ID (User ID):");
            if (recipient) {
                if (!conversations[recipient]) {
                    conversations[recipient] = {
                        partner: recipient,
                        avatar: 'default.png',
                        messages: [],
                        lastMessage: { message: 'New LP', created_at: new Date() }
                    };
                    renderConvoList();
                }
                selectConvo(recipient);
            }
        }

        async function init() {
            await loadSettings();
            allMessages = await fetchInbox();
            conversations = groupMessages(allMessages);
            renderConvoList();

            const urlParams = new URLSearchParams(window.location.search);
            const userParam = urlParams.get('user');

            if (userParam && !activeSender) {
                if (!conversations[userParam]) {
                    conversations[userParam] = {
                        partner: userParam,
                        avatar: 'default.png',
                        messages: [],
                        lastMessage: { message: 'New LP', created_at: new Date() }
                    };
                    renderConvoList();
                }
                selectConvo(userParam);
            } else if (activeSender) {
                if (conversations[activeSender]) renderMessages();
            }
        }

        document.getElementById('send-btn').onclick = sendMessage;
        document.getElementById('msg-input').onkeypress = (e) => { if (e.key === 'Enter') sendMessage(); };

        init();
        setInterval(init, 10000); 
    </script>
</body>

</html>